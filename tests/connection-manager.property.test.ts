/**
 * Property-Based Tests for Connection Manager
 * 
 * **Feature: mysql-readonly-mcp, Property 2: Credential Protection**
 * **Validates: Requirements 1.2, 8.3, 8.4**
 * 
 * Tests that the connection manager never exposes database credentials
 * in error messages or log outputs.
 */

import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import { 
  sanitizeMessage, 
  createConnectionErrorMessage 
} from '../src/connection-manager';
import type { DatabaseConfig } from '../src/types';

// Configure fast-check for minimum 100 iterations
fc.configureGlobal({ numRuns: 100 });

/**
 * Arbitrary for generating random passwords
 */
const passwordArb = fc.stringOf(
  fc.constantFrom(...'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*'.split('')),
  { minLength: 8, maxLength: 32 }
);

/**
 * Arbitrary for generating random hostnames
 * Excludes hostnames that could match credential patterns (password, pwd, secret, token, key)
 */
const hostnameArb = fc.stringOf(
  fc.constantFrom(...'abcdefghijklmnopqrstuvwxyz0123456789-.'.split('')),
  { minLength: 3, maxLength: 30 }
).filter(host => {
  // Exclude hostnames that could match credential patterns
  const lowerHost = host.toLowerCase();
  return !lowerHost.startsWith('password') && 
         !lowerHost.startsWith('pwd') && 
         !lowerHost.startsWith('secret') && 
         !lowerHost.startsWith('token') && 
         !lowerHost.startsWith('key');
});

/**
 * Arbitrary for generating random usernames
 */
const usernameArb = fc.stringOf(
  fc.constantFrom(...'abcdefghijklmnopqrstuvwxyz0123456789_'.split('')),
  { minLength: 3, maxLength: 20 }
);

/**
 * Arbitrary for generating random database names
 */
const databaseNameArb = fc.stringOf(
  fc.constantFrom(...'abcdefghijklmnopqrstuvwxyz0123456789_'.split('')),
  { minLength: 3, maxLength: 30 }
);

/**
 * Arbitrary for generating database configurations
 */
const databaseConfigArb = fc.record({
  name: fc.constantFrom('crm', 'operation'),
  host: hostnameArb,
  port: fc.integer({ min: 1024, max: 65535 }),
  user: usernameArb,
  password: passwordArb,
  database: databaseNameArb
}) as fc.Arbitrary<DatabaseConfig>;

/**
 * Arbitrary for generating error messages that might contain credentials
 */
const errorMessageWithCredentialsArb = fc.tuple(
  passwordArb,
  hostnameArb,
  usernameArb
).map(([password, host, user]) => {
  return fc.constantFrom(
    `Connection failed: password=${password}`,
    `Access denied for user '${user}'@'${host}' (using password: YES) password='${password}'`,
    `Error connecting to ${host} with pwd=${password}`,
    `Authentication failed: secret=${password}`,
    `Invalid token=${password} for connection`,
    `Connection string: mysql://${user}:${password}@${host}`,
    `Failed with key=${password}`,
    `password: ${password} is incorrect`,
    `pwd: "${password}" rejected`
  );
}).chain(arb => arb);


describe('Connection Manager Property Tests', () => {
  /**
   * Property 2: Credential Protection
   * 
   * *For any* error message or log output generated by the MCP_Server,
   * the output SHALL NOT contain database password strings or other 
   * sensitive credentials.
   */
  describe('Property 2: Credential Protection', () => {
    it('should never include password in connection error messages', () => {
      fc.assert(
        fc.property(
          databaseConfigArb,
          fc.string({ minLength: 1, maxLength: 100 }),
          (config, errorMsg) => {
            const error = new Error(errorMsg);
            const result = createConnectionErrorMessage(config, error);
            
            // Password should never appear in the error message
            expect(result).not.toContain(config.password);
            
            // Should contain safe connection details
            expect(result).toContain(config.name);
            expect(result).toContain(config.host);
            expect(result).toContain(config.database);
          }
        )
      );
    });

    it('should sanitize password patterns from any message', () => {
      fc.assert(
        fc.property(errorMessageWithCredentialsArb, (message) => {
          const sanitized = sanitizeMessage(message);
          
          // Should not contain common credential patterns
          expect(sanitized).not.toMatch(/password[=:]\s*['"]?[^'"\s]+['"]?/i);
          expect(sanitized).not.toMatch(/pwd[=:]\s*['"]?[^'"\s]+['"]?/i);
          expect(sanitized).not.toMatch(/secret[=:]\s*['"]?[^'"\s]+['"]?/i);
          expect(sanitized).not.toMatch(/token[=:]\s*['"]?[^'"\s]+['"]?/i);
          expect(sanitized).not.toMatch(/key[=:]\s*['"]?[^'"\s]+['"]?/i);
          
          // Should contain [REDACTED] placeholder
          expect(sanitized).toContain('[REDACTED]');
        })
      );
    });

    it('should preserve non-sensitive parts of error messages', () => {
      fc.assert(
        fc.property(
          hostnameArb,
          fc.integer({ min: 1024, max: 65535 }),
          databaseNameArb,
          (host, port, database) => {
            const message = `Connection to ${host}:${port}/${database} failed`;
            const sanitized = sanitizeMessage(message);
            
            // Non-sensitive info should be preserved
            expect(sanitized).toContain(host);
            expect(sanitized).toContain(port.toString());
            expect(sanitized).toContain(database);
          }
        )
      );
    });

    it('should handle messages without credentials unchanged', () => {
      fc.assert(
        fc.property(
          fc.stringOf(fc.constantFrom(...'abcdefghijklmnopqrstuvwxyz0123456789 .,!?'.split('')), 
            { minLength: 1, maxLength: 100 }),
          (message) => {
            // Messages without credential patterns should remain unchanged
            const sanitized = sanitizeMessage(message);
            
            // If no credential patterns, message should be unchanged
            if (!message.match(/password[=:]/i) && 
                !message.match(/pwd[=:]/i) && 
                !message.match(/secret[=:]/i) &&
                !message.match(/token[=:]/i) &&
                !message.match(/key[=:]/i)) {
              expect(sanitized).toBe(message);
            }
          }
        )
      );
    });

    it('should sanitize multiple credential patterns in same message', () => {
      fc.assert(
        fc.property(
          passwordArb,
          passwordArb,
          (password1, password2) => {
            const message = `password=${password1} and secret=${password2}`;
            const sanitized = sanitizeMessage(message);
            
            // Both passwords should be redacted
            expect(sanitized).not.toContain(password1);
            expect(sanitized).not.toContain(password2);
            
            // Should have multiple [REDACTED] placeholders
            const redactedCount = (sanitized.match(/\[REDACTED\]/g) || []).length;
            expect(redactedCount).toBeGreaterThanOrEqual(2);
          }
        )
      );
    });

    it('should handle various credential format patterns', () => {
      const credentialFormats = [
        (pwd: string) => `password=${pwd}`,
        (pwd: string) => `password="${pwd}"`,
        (pwd: string) => `password='${pwd}'`,
        (pwd: string) => `password: ${pwd}`,
        (pwd: string) => `pwd=${pwd}`,
        (pwd: string) => `secret=${pwd}`,
        (pwd: string) => `token=${pwd}`,
        (pwd: string) => `key=${pwd}`
      ];

      fc.assert(
        fc.property(
          passwordArb,
          fc.constantFrom(...credentialFormats),
          (password, formatFn) => {
            const message = formatFn(password);
            const sanitized = sanitizeMessage(message);
            
            // Password should be redacted regardless of format
            expect(sanitized).not.toContain(password);
            expect(sanitized).toContain('[REDACTED]');
          }
        )
      );
    });

    it('should create safe error messages for any database config', () => {
      fc.assert(
        fc.property(databaseConfigArb, (config) => {
          const error = new Error('Connection refused');
          const errorMessage = createConnectionErrorMessage(config, error);
          
          // Verify structure of error message
          expect(errorMessage).toContain('Database connection failed');
          expect(errorMessage).toContain(config.name);
          expect(errorMessage).toContain(config.host);
          expect(errorMessage).toContain(config.port.toString());
          expect(errorMessage).toContain(config.database);
          
          // Password must never appear
          expect(errorMessage).not.toContain(config.password);
        })
      );
    });
  });
});
